### 第18章 AI小镇应用

“AI小镇”是一类以小镇为生活背景、由AI参与管理的虚拟社区应用。该应用的功能可拓展到城市管理、社区服务、智能医疗等交互场景中。大语言模型的加入，促使这类应用发生了新的变化。生成式多轮对话、AI Agent、数字人等技术的应用，更加丰富了AI小镇的功能。 

2023年，出现了一些现象级的AI小镇应用，最有名的当数Smallville——来自斯坦福大学和Google的人工智能研究团队共同研发的一个完全由AI主导的虚拟世界。在这个虚拟场景中生活的25位居民均由AI控制，设定基础建筑设施及定义人物性格后，研究人员便不再干预，由程序自主运行和进化。观察发现，每一位小镇居民都会按照计划进行自己的生活，如做饭、写作、玩游戏或与朋友聊互相感兴趣的话题，其“生活”状态看起来很接近人类。 

本章会开发一个简化版的AI小镇程序，从而探索Generative Agent（生成式智能体）的实现方法。

#### 18.1 目标

本章使用React.js、2D游戏引擎Phaser3和大语言模型，开发一款RPG（角色扮演游戏）风格的AI小镇，多个角色在小镇地图限定范围内随机移动，若两两相遇则按设定的主题进行交谈，聊天的内容由大语言模型生成，有一定的随机性，可以进行多轮对话。一个功能完备、实用的AI小镇需要大量的设计和开发工作，本章的开发实例尽量对各个流程、场景进行简化，而详细描述开发过程并提供样例代码，目的在于向读者介绍AI小镇的实现思路和常用组件的使用方法。

#### 18.2 原理

目前已有的几个开源的AI小镇应用，如斯坦福AI小镇 、convex.dev/ai-town 等，架构都比较复杂，主要表现在组件众多、依赖GPT-4的生成能力、运行过程中会有费用支出等，实现真正意义上的本地化部署非常困难。 

AI小镇应用的主要实现方法是“游戏场景 + 大语言模型提示词定制”，其原理并不难理解，但是为了保证其合理性，要对其主要角色、NPC（非玩家角色）的人物特点进行定义，塑造不同的角色性格。另外，应用需要保存生活计划、聊天记录、进度等信息，这就造成了层级很多的应用架构，研究起来比较麻烦，也不利于本地化部署和开发。 

本章实现的AI小镇应用则消除了这些依赖关系，采用了第5章介绍的国产大模型作为对话服务提供者，所有组件都在本地部署。该应用的实现功能简单、构建思路清晰，读者更容易理解其开发过程并体验AI小镇的魅力。

##### 18.2.1 功能概要

将本章实现的AI小镇应用命名为AI-town，它实现了一个主要角色hero和若干个NPC在同一个地图上随机或受控移动，相遇时聊预设场景话题（如天气）的类游戏应用，对话的内容来自大语言模型的生成，支持多轮对话。 

1. **场景**：为了简化开发，AI-town只实现一个场景，这个场景的地图由Tiled绘制。Tiled是一款2D关卡编辑器，主要功能是编辑各种形式的瓦片地图，也支持免费的图像放置和NPC数据设置等。所谓瓦片地图，就是将地图分隔成若干个正方形，每个正方形在坐标系中占一个单位，这样就简化了坐标计算方法，避免用像素之类精确的方法描述位置，在角色移动的指令中只需要指定X和Y方向的偏移量即可。此外，Tiled可以设定碰撞检测和NPC的初始位置。 

2. **碰撞检测**：场景中的角色和NPC在一定范围内随机移动，碰到地图中的房屋、树木、河流等对象后，角色会重新调整方向继续移动。当角色与NPC的位置有交集时，两个发生碰撞的游戏人物就停止移动，开始多轮对话。对话完成后，双方继续随机移动。 

3. **对话历史**：为了减少依赖、便于本地化部署，除大语言模型外，应用开发的其他工作全部在客户端完成，即简化掉了中间层，所以数据不易持久保存，角色之间的对话记录会保存在客户端的全局变量中。这样做的优点是结构简单，缺点是刷新页面后，对话历史就会消失。不过作为一个入门级的例子，适当的流程简化有助于读者理解。 

4. **角色活动控制**：除了随机移动外，还可以通过鼠标或键盘控制角色移动。用户可以使用方向键控制角色在四个方向上的单步移动，也可以通过单击鼠标左键设定角色的移动目标位置。角色的移动路径由Phaser3的GridEngine插件计算和规划。


##### 18.2.2 系统架构

AI-town分为客户端和大语言模型服务两部分。关于大语言模型服务，前面已有介绍，所以AI-town的开发工作主要是在客户端进行的。 

AI-town客户端是由一个或数个Scene（场景）页面组成。在一个Scene内，包含了地图、角色、NPC的管理以及它们之间的交互。与一般的RPG相比，AI-town增加了调用大语言模型进行对话的功能。客户端的开发运行环境是React.js与Phaser3开发框架。Phaser3是一个流行的2D游戏框架，用于创建Web游戏和应用程序。它由Richard Davey创建，作为一个灵活且功能强大的工具，可以帮助开发人员快速轻松地构建游戏。Phaser3的功能包括物理引擎、动画、粒子系统、输入管理、音频支持等。在本例中使用了Phaser3的地图、碰撞检测和移动控制等组件。AI-town的架构见图18-1。 

![image](https://github.com/user-attachments/assets/d9a724c0-1252-4f81-b357-48f793e4376f)


##### 18.2.3 运行原理

Phaser3对RPG的开发组件进行了大量封装，但即使开发最简单的RPG，开发者也要考虑地图、场景、摄像机、碰撞检测、交互等元素，有一定的门槛。新建一个空白项目进行开发有一定的难度，而从一个具备基础功能的例程开始增减功能及进行个性化开发，则是一个相对容易的方案。 

AI-town以开源项目top-down-react-phaser-game作为原型，梳理程序流程，删除掉怪物、武器、健康值等AI-town用不到的功能，修改地图，以及做一些个性化的修改。 

程序运行的原理如图18-2所示。 

![image](https://github.com/user-attachments/assets/69aa534f-7c2c-407a-8f5e-38d995743a59)


1. **app.js**：AI-town使用React.js开发，其入口程序是app.js。在app.js中实现一些必要的初始化操作和HTML页面的载入。 

    - **初始化game对象**：在Phaser3的程序中，要创建全局game对象，并设置各种配置选项，包括游戏类型、标题、游戏画布的父元素、方向、宽度、高度、缩放选项、包含的场景（BootScene和GameScene）、物理引擎、游戏插件（GridEngine和RexUIPlugin）、背景颜色等。 
    - **注册对话框事件**：AI-town的程序主要分布在app.js、BootScene.js、GameScene.js和ChatUtils.js四个文件中。这些文件中，组件之间的交互消息是依靠事件传递的。比如，showdialogBoxEventListener监听名为show-dialog的事件，当事件触发时，更新角色名称和消息，这样的动作会使app.js显示对话框；closedialogBoxEventListener监听名为close-dialog的事件，当事件触发时，设置一个定时器，在2s后关闭对话框；gameHintEventListener监听名为game-hint的事件，当事件触发时，更新游戏提示文本，如果提示文本为空，则默认显示ai-town。 
    - **渲染页面**：通过React组件的return方法渲染游戏界面、相关提示框和对话框组件，根据状态的变化来更新内容，提供交互性和视觉反馈给用户。其中包含一个ID为game-content的div模块，代表game对象的父容器，将game对象注入页面中。 
    - **引导至BootScene场景**：完成以上工作后，将程序流程交由game对象控制，转向第一个场景BootScene。 

2. **BootScene.js**：BootScene对象在BootScene.js中定义，主要作用是预加载游戏用到的资源，该过程中可以用一个进度条显示加载进度，资源加载完成后，跳转到GameScene场景。 
    - **预加载资源**：首先，定义进度条显示加载进度和文本；然后加载游戏所需的各种资源，包括地图、图集、NPC、瓦片地图集和静态图片等。这样游戏在程序启动时就能够一次性加载所需的资源，进入主界面GameScene后，运行就会比较流畅。 
    - **引导至GameScene场景**：预加载完成后，启动游戏主场景GameScene，并传递角色状态（包含hero）和地图键名的初始参数，以便游戏场景能够正确初始化并顺利展示游戏内容。这些参数包括hero角色的初始位置、初始帧动画、初始朝向以及地图名。 

3. **GameScene.js** 
    - **初始化状态**：创建一些必要的变量和常量，包括摄像机、游戏实例、调试模式标志、hero角色状态、地图键名等。 
    - **注册交互事件**：设置了鼠标交互的监听事件，用于实现当用户鼠标左键弹起时，hero角色能够移动到所指位置的坐标；设置hero角色的随机移动事件，被触发后，hero角色开始随机移动位置；此外，还有显示修改话题的对话框事件和显示对话历史的事件。 
    - **创建地图**：首先创建一个地图实例，将瓦片集加载到地图中。为了便于调试，将游戏实例game赋值给全局变量window.phaserGame。 
    - **设置角色参数**：设置hero角色的精灵参数（用于判断碰撞），加载地图的各个图层，在hero角色与这些图层之间添加碰撞检测，以实现游戏中的碰撞交互效果。处理hero角色的动作、存在与否和物体碰撞检测，具体位置和大小参数根据hero角色的需求进行设置。 
    - **设置NPC参数**：初始化NPC，读取Tiled编辑器中制作的地图信息，枚举actions属性中保存的NPC数据，设置NPC的行为，包括出现在地图中的初始位置、随机移动等。 
    - **摄像机跟随**：设置摄像机跟随hero角色的行为，并根据地图大小调整摄像机的位置和边界。这一步骤实现了当hero角色移动时，像有摄像机一直跟踪它一样，能使角色始终显示在画面的中间位置。这种看似理所应当的效果，实际上是由摄像机组件完成的。 
    - **创建网格引擎**：GridEngine是一个用JavaScript语言实现的在二维网格上定位和移动对象的游戏计算引擎。它作为一个插件与Phaser3集成，可以用来移动hero角色、NPC的位置，并可检测到移动对象与地图或其他对象的碰撞。GridEngine支持对角线移动，还支持四向和八向移动。如果移动对象有特定的移动终点，还可以进行路线规划，通过一些策略引导对象抵达目的地。 
    - **碰撞后对话**：当hero角色与NPC碰撞后，两者停止移动，开始对话，使用GPT模型生成对话内容，且上下文相关。 


4. **ChatUtils.js**：使用openai-node组件调用大语言模型服务，调用的过程中将每轮对话存储到本地变量中，进行多轮会话。由于涉及多个NPC，所以对话历史以字典项保存，字典的key是NPC名字，value是此NPC与hero的对话过程。为了模拟出两两对话，中间还要有一个问题驱动层进行承上启下。这部分格式如下所示。 
```
conversationHistory = {
    "npc_01": [
        { "role": "user", "content": "当在小镇遇到熟人，聊天气，随机写一个开始话题" },
        { "role": "assistant", "content": "天气不错，准备去哪？" },
        { "role": "user", "content": "当在小镇遇到熟人，聊天气，熟人说：“天气不错，准备去哪？”，随机写一个回答" },
        { "role": "assistant", "content": "去健身啊！" },
        { "role": "user", "content": "当在小镇遇到熟人，聊天气，熟人说：“去健身啊！”，随机写一个回答" },
        { "role": "assistant", "content": "好的，再见" }
    ]
}
```

#### 18.3 开发过程

与以往从零搭建项目不同，AI-town项目包含众多文件类型，如JavaScript脚本、CSS、地图文件、静态文件、配置文件、对话框和HTML文件等。因此，我们将逐步解析现有代码并详细介绍开发过程。通过结合源码和课程内容，读者能够更容易理解整个项目的构建。 

本章的代码位于https://github.com/little51/llm-dev/tree/main/chapter18/ai-town。 
